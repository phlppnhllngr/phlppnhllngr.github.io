---
title: kubectl
parent: Kubernetes
grand_parent: DevOps
---

# kubectl
- *The kubectl command line tool lets you control Kubernetes clusters. deploy applications, inspect and manage cluster resources, and view logs*
- *submits commands to master-node's api server*
- Die Commands, die Ressourcen (Deployments, Pods, ...) betreffen, können z. T. auch via YAML-Files abgebildet werden (imperativ vs. deklarativ)
- Connection-Info gespeichert in $HOME/.kube/config
- <https://kubernetes.io/docs/reference/kubectl/cheatsheet/>

## Commands
- **apply**
  - *create or update a component (e. g. deployment) from config file [declaratively]*
  - *k8s knows whether to update or create the component*
  - `kubectl apply -f <config-file>`
  - `--kustomize`
    - `kubectl apply -k path/to/kustomization.yaml`
    - für "Base"- und "Overlay"-Konfigurationen (z. B. Dev, Test, Prod)
    - `namespace=<ns>` um sicherzustellen, dass eine spezielle Konfig auch wirklich nur in der Vorgesehenen Umgebung (NS) applied wird
    - <https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/>
    - <https://kubectl.docs.kubernetes.io/references/kustomize/>
- **cluster-info**
- **config**
  - current-context
  - get-contexts
  - set-context
    - Namespace ändern: `set-context --current --namespace=<ns>`
  - use-context \<contextName>
  - view
    - `kubectl config view`
- **create**
  - `kubectl create -h`
  - mit `--dry-run=client --output yaml --save-config > foo.yaml` können Ressourcen-Yamls erstellt werden
  - deployment
    - *create and run pod and replicaset*
    - `kubectl create deployment <name> --image=<image> [--dry-run] [--port] [--replicas=<number>] [...]`
- **delete**
  - `kubectl delete deployment <deployment>`
  - `kubectl delete -f <config-file>`
  - `kubectl delete pod --grace-period=<number>`
  - `kubectl delete pod --grace-period=0 --force`
- **describe**
  - `kubectl describe pod <pod>`
- **edit**
  - *edit deployment configurations* (öffnet Texteditor)
  - `kubectl edit deployment nginx`
- **exec**
  - `kubectl exec -it <pod> -- /bin/sh`
- **explain**
  - `kubectl explain Pod.spec`
- **expose**
  - Erzeugt einen Service, um einen Pod oder ein Deployment zu exposen
  - `kubectl expose deploy --name=<name> --port=<number> --targetPort=<number>`
  - `kubectl expose deployment hello-node --type=LoadBalancer --port=8080`
  - *The --type=LoadBalancer flag indicates that you want to expose your Service outside of the cluster.*
  - *On cloud providers that support load balancers, an external IP address would be provisioned to access the Service. On minikube, the LoadBalancer type makes the Service accessible through the `minikube service` command.*
- **get**
  - `kubectl get all|nodes|ns|pods|services|deployments|replicasets|events|endpoints|...`
  - `get all` listet nicht alle Ressourcen! => `kubectl get all,cm,ing,...` (`kubectl api-resources --verbs=list`) (<https://github.com/kubernetes/kubectl/issues/151>)
  - `get pods --all-namespaces --output wide --selector=foo=bar --watch`
  - `get pods -n <ns> | get pods --namespace=<ns>`
  - `get pod <podname> -o wide`
  - `get pod <podname> -o yaml > pod.yaml`
  - mit Labels
    - `get pods -l 'env in (dev, test)' --show-labels`
    - `get pods -l foo=bar --show-labels`
- **kustomize**
  - gibt den von kustomize generierten Inhalt aus (Dry-Run)
- **label**
  - updated Labels einer Ressource 
- **logs**
  - `kubectl logs [--previous] [--tail=<n>] [--follow] <pod>`
  - bei CrashLoopBackoff: `kubectl logs deployment/foo --all-containers`
- **patch**
- **port-forward**
  - *in Kubernetes, every pod gets its own ip address from 10.*, that is usable only within the cluster. Now, the port-forward feature of kubectl simply tunnels the traffic from a specified port at your local host machine to the specified port on the specified pod. API server then becomes, in a sense, a temporary gateway between your local port and the Kubernetes cluster*
  - *kubectl port-forward is more generic as it can forward TCP traffic while kubectl proxy can only forward HTTP traffic.*
  - *useful for testing/debugging purposes so you can access your service locally without exposing it*
  - `kubectl port-forward pods/podname 8080:80`
  - `kubectl port-forward services/fooservice 8080:80`
- **proxy**
- **rollout**
  - für Deployment mit RollingUpdate 
  - status \<deployment>
  - undo 
- **run**
  - Pod starten (imperativ) 
  - `run <podname> --image=<image> [-it] -- /bin/sh -c "..."`
- **scale**
  - `--replicas=<n>` 
- **top**
- **wait**
  - `--selector=foo=bar --timeout=10s --for-condition=ready pod`
- <https://kubernetes.io/docs/reference/kubectl/>
